<img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png" width="150" alt="UPC Logo">

# Universidad Peruana de Ciencias Aplicadas

### **CURSO:** Aplicaciones para Dispositivos Moviles

### **NRC**: 358

### **Profesor:** Eduardo Martin Reyes Rodriguez

### **Ingeniería de software**

## Informe de Trabajo Final

### **Nombre del startup:** NRG4

### **Nombre del producto:** SynHome

## **Integrantes**


| **Nombre**                                | **Codigo** |
| ----------------------------------------- | ---------- |
| **Alejo Cardenas Jose Antonio**           | U202122484 |
| **Astonitas Díaz Juan Diego**            | U202110237 |
| **Casas Sanchez Gabriel Alexander**       | U202220033 |
| **Pacheco Astiguetta Sebastian**          | U202110291 |
| **Pasquale Barrenechea Gianluca Santino** | U202112078 |

**Abril 2025**

## Registro de Versiones del Informe


| Versión | Fecha | Autor | Descripción de modificación |
| -------- | ----- | ----- | ----------------------------- |

## Project Report Collaboration Insights

## Contenido

- [Student Outcome](#student-outcome)
- [Objetivos SMART](#objetivos-smart)
- [Capitulo I: Presentación](#capitulo-i)
  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripcion-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problematica)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos Objetivo](#13-segmentos-objetivo)
- [Capítulo II: Requirements Elicitation & Analysis](#capitulo-ii)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. Análisis competitivo ](#211-analisis-competitivo)
    - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tacticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Diseño de entrevistas ](#221-diseno-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. Análisis de entrevistas](#223-analisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
    - [2.3.4. Empathy Mapping](#234-empathy-mapping)
    - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
  - [2.4. Ubiquitous Language](#24-ubiquitous-language)
- [Capítulo III: Requirements specification](#capitulo-iii)
  - [3.1. To-Be Scenario Mapping](#251-to-be-scenario-mapping)
  - [3.2. User Stories](#252-user-stories)
  - [3.3. Impact Mapping](#253-impact-mapping)
  - [3.4. Product Backlog](#254-product-backlog)
- [Capítulo IV: Solution Software Design](#capitulo-iv)
  - [4.1. Strategic-Level Domain-Driven Design](#41-strategic-level-domain-driven-design)
    - [4.1.1. EventStorming](#411-eventstorming)
      - [4.1.1.1. Candidate Context Discovery](#4111-candidate-context-discovery)
      - [4.1.1.2. Domain Message Flows Modeling](#4112-domain-message-flows-modeling)
      - [4.1.1.3. Bounded Context Canvases](#4113-bounded-context-canvases)
    - [4.1.2. Context Mapping](#412-context-mapping)
    - [4.1.3. Software Architecture](#413-software-architecture)
      - [4.1.3.1. Software Architecture Context Level Diagrams](#4131-software-architecture-context-level-diagrams)
      - [4.1.3.2. Software Architecture Container Level Diagrams](#4132-software-architecture-container-level-diagrams)
      - [4.1.3.3. Software Architecture Deployment Diagrams](#4133-software-architecture-deployment-diagrams)
  - [4.2. Tactical-Level Domain-Driven Design](#42-tactical-level-domain-driven-design)
    - [4.2.1. Bounded Context:](#421-bounded-context)
      - [4.2.1.1. Domain Layer](#4211-domain-layer)
      - [4.2.1.2. Interface Layer](#4212-interface-layer)
      - [4.2.1.3. Application Layer](#4213-application-layer)
      - [4.2.1.4. Infrastructure Layer](#4214-infrastructure-layer)
      - [4.2.1.5. Bounded Context Software Architecture Component Level Diagrams](#4215-bounded-context-software-architecture-component-level-diagrams)
      - [4.2.1.6. Bounded Context Software Architecture Code Level Diagrams](#4216-bounded-context-software-architecture-code-level-diagrams)
        - [4.2.1.6.1. Bounded Context Domain Layer Class Diagrams](#42161-bounded-context-domain-layer-class-diagrams)
        - [4.2.1.6.2. Bounded Context Database Design Diagram](#42162-bounded-context-database-design-diagram)
- [Capítulo V: Solution UI/UX Design](#capitulo-v)
  - [5.1. Product Design](#51-product-design)
    - [5.1.1. Style Guidelines](#511-style-guidelines)
      - [5.1.1.1. General Style Guidelines](#5111-general-style-guidelines)
    - [5.1.2. Information Architecture](#512-information-architecture)
      - [5.1.2.1. Organization Systems](#5121-organization-systems)
      - [5.1.2.2. Labeling Systems](#5122-labeling-systems)
      - [5.1.2.3. SEO Tags and Meta Tags](#5123-seo-tags-and-meta-tags)
      - [5.1.2.4. Searching Systems](#5124-searching-systems)
      - [5.1.2.5. Navigation Systems](#5125-navigation-systems)
    - [5.1.3. Landing Page UI Design](#513-landing-page-ui-design)
      - [5.1.3.1. Landing Page Wireframe](#5131-landing-page-wireframe)
      - [5.1.3.2. Landing Page Mock-up](#5132-landing-page-mock-up)
    - [5.1.4. Mobile Applications UX/UI Design](#514-mobile-applications-ux-ui-design)
      - [5.1.4.1. Mobile Applications Wireframes](#5141-mobile-applications-wireframes)
      - [5.1.4.2. Mobile Applications Wireflow Diagrams](#5142-mobile-applications-wireflow-diagrams)
      - [5.1.4.3. Mobile Applications Mock-ups](#5143-mobile-applications-mock-ups)
      - [5.1.4.4. Mobile Applications User Flow Diagrams](#5144-mobile-applications-user-flow-diagrams)
      - [5.1.4.5. Mobile Applications Prototyping](#5145-mobile-applications-prototyping)
- [Capítulo VI: Product Implementation, Validation & Deployment](#capitulo-vi)
  - [6.1. Software Configuration Management](#61-software-configuration-management)
    - [6.1.1. Software Development Environment Configuration](#611-software-development-environment-configuration)
    - [6.1.2. Source Code Management](#612-source-code-management)
    - [6.1.3. Source Code Style Guide & Conventions](#613-source-code-style-guide--conventions)
    - [6.1.4. Software Deployment Configuration](#614-software-deployment-configuration)
  - [6.2. Landing Page & Mobile Application Implementation](#62-landing-page--mobile-application-implementation)
    - [6.2.1. Sprint 1](#621-sprint-1)
      - [6.2.1.1. Sprint Planning 1](#6211-sprint-planning-1)
      - [6.2.1.2. Sprint Backlog 1](#6212-sprint-backlog-1)
      - [6.2.1.3. Development Evidence for Sprint Review](#6213-development-evidence-for-sprint-review)
      - [6.2.1.4. Testing Suite Evidence for Sprint Review](#6214-testing-suite-evidence-for-sprint-review)
      - [6.2.1.5. Execution Evidence for Sprint Review](#6215-execution-evidence-for-sprint-review)
      - [6.2.1.6. Services Documentation Evidence for Sprint Review](#6216-services-documentation-evidence-for-sprint-review)
      - [6.2.1.7. Software Deployment Evidence for Sprint Review](#6217-software-deployment-evidence-for-sprint-review)
      - [6.2.1.8. Team Collaboration Insights during Sprint](#6218-team-collaboration-insights-during-sprint)
  - [6.3. Validation Interviews](#63-validation-interviews)
    - [6.3.1. Diseño de entrevistas](#631-diseno-de-entrevistas)
    - [6.3.2. Registro de entrevistas](#632-registro-de-entrevistas)
    - [6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-segun-heuristicas)
  - [6.4. Video About-the-Product](#64-video-about-the-product)
- [Conclusiones](#conclusiones)
- [Bibliografía](#bibliografía)
- [Anexos](#anexos)

## Student Outcome

## Objetivos SMART

## Capitulo I

### 1.1. Startup Profile

#### 1.1.1. Descripción de la Startup

#### 1.1.2. Perfiles de integrantes del equipo

### 1.2. Solution Profile

#### 1.2.1. Antecedentes y problemática

#### 1.2.2. Lean UX Process

##### 1.2.2.1. Lean UX Problem Statements

##### 1.2.2.2. Lean UX Assumptions

##### 1.2.2.3. Lean UX Hypothesis Statements

##### 1.2.2.4. Lean UX Canvas

### 1.3. Segmentos Objetivo

## Capítulo II: Requirements Elicitation & Analysis

### 2.1. Competidores

#### 2.1.1. Análisis competitivo

#### 2.1.2. Estrategias y tácticas frente a competidores

### 2.2. Entrevistas

#### 2.2.1. Diseño de entrevistas

#### 2.2.2. Registro de entrevistas

#### 2.2.3. Análisis de entrevistas

### 2.3. Needfinding

#### 2.3.1. User Personas

#### 2.3.2. User Task Matrix

#### 2.3.3. User Journey Mapping

#### 2.3.4. Empathy Mapping

#### 2.3.5. As-is Scenario Mapping

### 2.4. Ubiquitous Language

## Capítulo III: Requirements specification

### 3.1. To-Be Scenario Mapping

### 3.2. User Stories

### 3.3. Impact Mapping

### 3.4. Product Backlog

## Capítulo IV: Solution Software Design

### 4.1. Strategic-Level Domain-Driven Design

En esta sección se presenta el enfoque adoptado para tomar decisiones estratégicas en el desarrollo del sistema, aplicando los principios del Domain-Driven Design (DDD). El objetivo principal fue identificar y establecer los límites naturales del dominio, descomponiendo la solución en Bounded Contexts.

Para lograr esta descomposición, el equipo empleó herramientas colaborativas clave como Event Storming, que permitió mapear y visualizar de forma dinámica los flujos de eventos, comandos y actores dentro del dominio; y el Bounded Context Canvas, utilizado para definir los elementos esenciales de cada contexto, incluyendo objetivos, modelos, responsabilidades y relaciones con otros contextos.

Este proceso estratégico permitió no solo estructurar el sistema de manera más coherente, sino también alinear las decisiones técnicas con los objetivos de negocio, facilitando la comunicación entre los distintos actores involucrados en el desarrollo del proyecto.

#### 4.1.1. EventStorming

En esta sección se expone y fundamenta el proceso de **EventStorming** llevado a cabo por el equipo, con el propósito de construir una primera aproximación al modelado general del dominio del problema. Esta técnica, centrada en la identificación de eventos relevantes dentro del sistema, permite capturar el conocimiento colectivo de los participantes y detonar conversaciones clave sobre el comportamiento esperado del sistema en distintos escenarios.

La sesión fue organizada estratégicamente con una duración de entre una a dos horas. Durante esta actividad, se emplearon post-its digitales para representar eventos y comandos lo que facilitó una exploración visual e iterativa del flujo de trabajo.

<img src="images/chapter-4/eventStorming1.png">

##### 4.1.1.1. Candidate Context Discovery
Una vez finalizada la sesión de Event Storming, se realizó un análisis exhaustivo de los eventos identificados, con el objetivo de descubrir los contextos candidatos que podrían ser relevantes para el dominio del problema. Este proceso implicó la identificación de patrones y relaciones entre los eventos, así como la evaluación de su impacto en el sistema. 
Gracias a esto se establecieron listados de eventos que formaban parte de un mismo proceso de acción para la aplicación.

<img src="images/chapter-4/eventStorming2.png">

A continuación se muestra con detalle las líneas de acción creadas:

**Creación de grupo**

<img src="images/chapter-4/eventStorming2-1.png" alt="Creación de grupo" width="600"/>

**Asignación de tareas**

<img src="images/chapter-4/eventStorming2-2.png" alt="Asignación de tareas" width="600"/>

**Modificación de tareas**

<img src="images/chapter-4/eventStorming2-3.png" alt="Modificación de tareas" width="600"/>

**Cumplimiento de tareas**

<img src="images/chapter-4/eventStorming2-4.png" alt="Cumplimiento de tareas" width="600"/>

**Incumplimiento de tareas**

<img src="images/chapter-4/eventStorming2-5.png" alt="Incumplimiento de tareas" width="600"/>

Una vez creadas las líneas de acción se buscó encontrar los "pain points", solo se tuvo que modificar la línea de acción de creación de grupo.
**Creación de grupo**

<img src="images/chapter-4/eventStorming2-1-1.png" alt="Creación de grupo" width="600"/>

Una vez terminadas las líneas de acción se buscó encontrar los "pivotal point", los cuales son eventos que pueden cambiar el flujo de la aplicación.
Los pivotal point encontrados fueron:
- La creación de un grupo
- La creación de una tarea
- La modificación de una tarea
- La asignación de una tarea
- Acciones que requieran enviar notificaciones
- El cumplimiento de tareas
- El incumplimiento de tareas

Gracias a encontrar los pivotal points se pudo identificar como los distintos eventos formaban parte de distintos contextos, los cuales son:
- Gestión de grupos
- Notificaciones
- Gestión de tareas
- Análitica y reportes
- Solicitudes y Validaciones

Finalmente se dividio cada evento en comandos, eventos, agregados, vistas y entidades, los cuales son los siguientes:
**Gestión de grupos**

<img src="images/chapter-4/eventStorming3-1.png" alt="Gestión de grupos" width="600"/>

**Notificaciones**

<img src="images/chapter-4/eventStorming3-2.png" alt="Notificaciones" width="600"/>

**Gestión de tareas**

<img src="images/chapter-4/eventStorming3-3.png" alt="Notificaciones" width="600"/>

**Análitica y reportes**

<img src="images/chapter-4/eventStorming3-4.png" alt="Análitica y reportes" width="600"/>

**Solicitudes y Validaciones**

<img src="images/chapter-4/eventStorming3-5.png" alt="Solicitudes y Validaciones" width="600"/>

##### 4.1.1.2. Domain Message Flows Modeling
Como siguiente paso se buscó interconectar los bounded contexts encontrados en la sección anterior, para esto se buscó encontrar los eventos que se comunican entre los distintos contextos.

**Gestión de grupos y notificaciones:** Al generar una invitación de grupo se envía una notificación al usuario invitado, y al aceptar la invitación se envía una notificación al creador del grupo.

<img src="images/chapter-4/flowModeling1.png" alt="Gestión de grupos y notificaciones" width="600"/>

**Gestión de tareas y notificaciones:** Al crear una tarea se envía una notificación al usuario asignado, y al cumplir la tarea se envía una notificación al creador de la tarea.

<img src="images/chapter-4/flowModeling2.png" alt="Gestión de tareas y notificaciones" width="600"/>

**Notificaciones y Solicitudes y Validaciones:** Al crear una solicitud de validación se envía una notificación al usuario asignado, y al aceptar la solicitud se envía una notificación al creador de la solicitud.

<img src="images/chapter-4/flowModeling3.png" alt="Notificaciones y Solicitudes y Validaciones" width="600"/>

**Solicitudes y Validadciones y Análitica y reportes:** Al validarse si se completó o no una tarea se crean o modifican las estadísticas de progreso grupal.

<img src="images/chapter-4/flowModeling4.png" alt="Solicitudes y Validadciones y Análitica y reportes" width="600"/>

**Solicitudes y Validadciones y Notificaciones:** Al momento de marcarse tareas como completadas o no completadas se envía una notificación al coordinador. Al asignar reprogramar tareas se enviará notificaciones al usuario antiguo y al nuevo usuario al que pertenece la tarea. Al modificar(actualizar, reprogramar o eliminar) tareas se enviará una notificación a todos los involucrados (coordinadores e integrantes).

<img src="images/chapter-4/flowModeling5.png" alt="Solicitudes y Validadciones y Notificaciones" width="600"/>

Finalmente se muestra una captura global de la arquitectura del sistema, donde se puede ver la interacción entre los distintos componentes y como se comunican entre ellos.

<img src="images/chapter-4/flowModeling6.png" alt="Architecture" width="600"/>

Enlace del Miro board sobre el que se trabajo: https://miro.com/app/board/uXjVIAKXzls=/?share_link_id=902923638078

##### 4.1.1.3. Bounded Context Canvases

#### 4.1.2. Context Mapping

#### 4.1.3. Software Architecture

La arquitectura del sistema se estructura en tres niveles: el Context Diagram define las interacciones externas entre SynHub (núcleo del sistema), sus usuarios (Miembro, Líder) y servicios externos (Google Calendar); el Container Diagram descompone SynHub en módulos clave (Mobile App, API REST, PostgreSQL y Landing Page), detallando sus responsabilidades y comunicación interna; y el Deployment Diagram especifica el despliegue físico/cloud de estos componentes, incluyendo servidores, dispositivos móviles y conexiones con APIs externas. Juntos, garantizan un diseño escalable, integrado y bien organizado.

##### 4.1.3.1. Software Architecture Context Level Diagrams

El Context Diagram muestra a SynHub (el sistema central) interactuando con sus usuarios principales —el Miembro y el Líder— quienes utilizan la aplicación para gestionar actividades, mientras que SynHub se integra con Google Calendar para sincronizar eventos externos. Este diagrama enfatiza las relaciones externas del sistema, sin detallar componentes internos, destacando cómo los actores clave (usuarios y servicios externos) se conectan con la plataforma principal para intercambiar información.

<img src="images/chapter-4/contextDiagram.png" alt="Context Diagram" width="600"/>

##### 4.1.3.2. Software Architecture Container Level Diagrams

El Container Diagram describe la arquitectura del sistema, donde los usuarios (Miembro y Líder) interactúan con la Landing Page (web) y la Mobile App, las cuales se conectan a una API REST (backend) que gestiona la lógica de negocio. Esta API se comunica con una base de datos PostgreSQL para almacenar datos y con Google Calendar (mediante su API) para sincronizar eventos. Cada componente (frontend, backend, base de datos y servicio externo) opera en contenedores o entornos independientes, conectados a través de APIs RESTful (HTTPS/JSON) y protocolos como JDBC (PostgreSQL) y OAuth 2.0 (Google).

<img src="images/chapter-4/containerDiagram.png" alt="Container Diagram" width="600"/>

##### 4.1.3.3. Software Architecture Deployment Diagrams

El diagrama de despliegue representa un sistema donde una aplicación móvil se comunica con una API REST mediante HTTP/HTTPS; esta API gestiona la lógica de negocio, interactúa con una base de datos PostgreSQL para almacenar datos y se integra con Google Calendar a través de su API  para sincronizar eventos. Los componentes clave incluyen: la app (frontend), el servidor de la API (backend), la base de datos (almacenamiento) y el servicio externo de Google , conectados mediante protocolos como RESTful APIs (JSON).

<img src="images/chapter-4/deploymentDiagram.png" alt="Deployment Diagram" width="600"/>

### 4.2. Tactical-Level Domain-Driven Design

#### 4.2.1. Bounded Context:

##### 4.2.1.1. Domain Layer

##### 4.2.1.2. Interface Layer

##### 4.2.1.3. Application Layer

##### 4.2.1.4. Infrastructure Layer

##### 4.2.1.5. Bounded Context Software Architecture Component Level Diagrams

##### 4.2.1.6. Bounded Context Software Architecture Code Level Diagrams

###### 4.2.1.6.1. Bounded Context Domain Layer Class Diagrams

###### 4.2.1.6.2. Bounded Context Database Design Diagram

## Capítulo V: Solution UI/UX Design

### 5.1. Product Design

#### 5.1.1. Style Guidelines

##### 5.1.1.1. General Style Guidelines

#### 5.1.2. Information Architecture

##### 5.1.2.1. Organization Systems

##### 5.1.2.2. Labeling Systems

##### 5.1.2.3. SEO Tags and Meta Tags

##### 5.1.2.4. Searching Systems

##### 5.1.2.5. Navigation Systems

#### 5.1.3. Landing Page UI Design

##### 5.1.3.1. Landing Page Wireframe

##### 5.1.3.2. Landing Page Mock-up

#### 5.1.4. Mobile Applications UX/UI Design

##### 5.1.4.1. Mobile Applications Wireframes

##### 5.1.4.2. Mobile Applications Wireflow Diagrams

##### 5.1.4.3. Mobile Applications Mock-ups

##### 5.1.4.4. Mobile Applications User Flow Diagrams

##### 5.1.4.5. Mobile Applications Prototyping

## Capítulo VI: Product Implementation, Validation & Deployment

### 6.1. Software Configuration Management

#### 6.1.1. Software Development Environment Configuration

#### 6.1.2. Source Code Management

#### 6.1.3. Source Code Style Guide & Conventions

#### 6.1.4. Software Deployment Configuration

### 6.2. Landing Page & Mobile Application Implementation

#### 6.2.1. Sprint 1

##### 6.2.1.1. Sprint Planning 1

##### 6.2.1.2. Sprint Backlog 1

##### 6.2.1.3. Development Evidence for Sprint Review

##### 6.2.1.4. Testing Suite Evidence for Sprint Review

##### 6.2.1.5. Execution Evidence for Sprint Review

##### 6.2.1.6. Services Documentation Evidence for Sprint Review

##### 6.2.1.7. Software Deployment Evidence for Sprint Review

##### 6.2.1.8. Team Collaboration Insights during Sprint

### 6.3. Validation Interviews

#### 6.3.1. Diseño de entrevistas

#### 6.3.2. Registro de entrevistas

#### 6.3.3. Evaluaciones según heurísticas

### 6.4. Video About-the-Product

## Conclusiones

## Bibliografía

## Anexos
